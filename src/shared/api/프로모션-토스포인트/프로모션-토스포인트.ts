/**
 * Generated by orval v8.1.0 üç∫
 * Do not edit manually.
 * OnSurvey API Docs
 * OnSurvey Spring boot Api Document ÏûÖÎãàÎã§.
 * OpenAPI spec version: 0.0.1
 */

import type {
	MutationFunction,
	QueryClient,
	UseMutationOptions,
	UseMutationResult,
} from "@tanstack/react-query";
import { useMutation } from "@tanstack/react-query";
import { apiClient } from "../axios/orvalMutator";
import type {
	PromotionIssueRequest,
	PromotionRecheckPendingRequest,
} from ".././model";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * PENDING ÏÉÅÌÉúÎ°ú ÎÇ®ÏïÑÏûàÎäî ÌîÑÎ°úÎ™®ÏÖòÎì§ÏùÑ Ïû¨Ï°∞ÌöåÌïòÏó¨ ÏµúÏã† ÏÉÅÌÉúÎ°ú Í∞±Ïã†Ìï©ÎãàÎã§.
 * @summary [Ìò∏Ï∂ú Ïú†Ïùò] PENDING ÌîÑÎ°úÎ™®ÏÖò Ïû¨Ï°∞Ìöå
 */
export const getRecheckPendingUrl = () => {
	return `/toss/promotion/recheck-pending`;
};

export const recheckPending = async (
	promotionRecheckPendingRequest: PromotionRecheckPendingRequest,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getRecheckPendingUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(promotionRecheckPendingRequest),
	});
};

export const getRecheckPendingMutationOptions = <
	TError = Blob,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof recheckPending>>,
		TError,
		{ data: PromotionRecheckPendingRequest },
		TContext
	>;
	request?: SecondParameter<typeof apiClient>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof recheckPending>>,
	TError,
	{ data: PromotionRecheckPendingRequest },
	TContext
> => {
	const mutationKey = ["recheckPending"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof recheckPending>>,
		{ data: PromotionRecheckPendingRequest }
	> = (props) => {
		const { data } = props ?? {};

		return recheckPending(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RecheckPendingMutationResult = NonNullable<
	Awaited<ReturnType<typeof recheckPending>>
>;
export type RecheckPendingMutationBody = PromotionRecheckPendingRequest;
export type RecheckPendingMutationError = Blob;

/**
 * @summary [Ìò∏Ï∂ú Ïú†Ïùò] PENDING ÌîÑÎ°úÎ™®ÏÖò Ïû¨Ï°∞Ìöå
 */
export const useRecheckPending = <TError = Blob, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof recheckPending>>,
			TError,
			{ data: PromotionRecheckPendingRequest },
			TContext
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof recheckPending>>,
	TError,
	{ data: PromotionRecheckPendingRequest },
	TContext
> => {
	return useMutation(getRecheckPendingMutationOptions(options), queryClient);
};
/**
 * ÌîÑÎ°úÎ™®ÏÖò ÏΩîÎìú/Í∏àÏï°ÏúºÎ°ú ÌÜ†Ïä§ Ìè¨Ïù∏Ìä∏ ÏßÄÍ∏âÏùÑ Ïã§ÌñâÌï©ÎãàÎã§.
 * @summary ÌÜ†Ïä§Ìè¨Ïù∏Ìä∏ ÏßÄÍ∏â Ïã§Ìñâ
 */
export const getIssueUrl = () => {
	return `/toss/promotion/issue`;
};

export const issue = async (
	promotionIssueRequest: PromotionIssueRequest,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getIssueUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(promotionIssueRequest),
	});
};

export const getIssueMutationOptions = <
	TError = Blob,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof issue>>,
		TError,
		{ data: PromotionIssueRequest },
		TContext
	>;
	request?: SecondParameter<typeof apiClient>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof issue>>,
	TError,
	{ data: PromotionIssueRequest },
	TContext
> => {
	const mutationKey = ["issue"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof issue>>,
		{ data: PromotionIssueRequest }
	> = (props) => {
		const { data } = props ?? {};

		return issue(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type IssueMutationResult = NonNullable<
	Awaited<ReturnType<typeof issue>>
>;
export type IssueMutationBody = PromotionIssueRequest;
export type IssueMutationError = Blob;

/**
 * @summary ÌÜ†Ïä§Ìè¨Ïù∏Ìä∏ ÏßÄÍ∏â Ïã§Ìñâ
 */
export const useIssue = <TError = Blob, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof issue>>,
			TError,
			{ data: PromotionIssueRequest },
			TContext
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof issue>>,
	TError,
	{ data: PromotionIssueRequest },
	TContext
> => {
	return useMutation(getIssueMutationOptions(options), queryClient);
};
