/**
 * Generated by orval v8.1.0 üç∫
 * Do not edit manually.
 * OnSurvey API Docs
 * OnSurvey Spring boot Api Document ÏûÖÎãàÎã§.
 * OpenAPI spec version: 0.0.1
 */

import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseInfiniteQueryResult,
	DefinedUseQueryResult,
	InfiniteData,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseInfiniteQueryOptions,
	UseInfiniteQueryResult,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import {
	useInfiniteQuery,
	useMutation,
	useQuery,
	useSuspenseQuery,
} from "@tanstack/react-query";
import { apiClient } from "../axios/orvalMutator";
import type {
	GetImpendingSurveyListParams,
	GetQuestionsOfSurveyIdParams,
	GetRecommendedScreeningsParams,
	GetRecommendedSurveyListParams,
	GetSurveyInfoParams,
	GetSurveyListOnGoingParams,
	GetTotalSurveyInfoOfSurveyIdParams,
	InsertQuestionAnswerRequest,
	InsertScreeningAnswerRequest,
} from ".././model";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary ÏÑ§Î¨∏Ïóê ÎåÄÌïú ÏùëÎãµÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const getCreateQuestionAnswerUrl = (surveyId: number) => {
	return `/v1/survey-participation/surveys/${surveyId}`;
};

export const createQuestionAnswer = async (
	surveyId: number,
	insertQuestionAnswerRequest: InsertQuestionAnswerRequest,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getCreateQuestionAnswerUrl(surveyId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(insertQuestionAnswerRequest),
	});
};

export const getCreateQuestionAnswerMutationOptions = <
	TError = Blob,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createQuestionAnswer>>,
		TError,
		{ surveyId: number; data: InsertQuestionAnswerRequest },
		TContext
	>;
	request?: SecondParameter<typeof apiClient>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createQuestionAnswer>>,
	TError,
	{ surveyId: number; data: InsertQuestionAnswerRequest },
	TContext
> => {
	const mutationKey = ["createQuestionAnswer"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createQuestionAnswer>>,
		{ surveyId: number; data: InsertQuestionAnswerRequest }
	> = (props) => {
		const { surveyId, data } = props ?? {};

		return createQuestionAnswer(surveyId, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateQuestionAnswerMutationResult = NonNullable<
	Awaited<ReturnType<typeof createQuestionAnswer>>
>;
export type CreateQuestionAnswerMutationBody = InsertQuestionAnswerRequest;
export type CreateQuestionAnswerMutationError = Blob;

/**
 * @summary ÏÑ§Î¨∏Ïóê ÎåÄÌïú ÏùëÎãµÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const useCreateQuestionAnswer = <TError = Blob, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof createQuestionAnswer>>,
			TError,
			{ surveyId: number; data: InsertQuestionAnswerRequest },
			TContext
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof createQuestionAnswer>>,
	TError,
	{ surveyId: number; data: InsertQuestionAnswerRequest },
	TContext
> => {
	return useMutation(
		getCreateQuestionAnswerMutationOptions(options),
		queryClient,
	);
};
/**
 * @summary ÏÑ§Î¨∏ Ï∞∏Ïó¨ Ï§ëÏûÑÏùÑ ÏïåÎ¶ΩÎãàÎã§.
 */
export const getSendHeartbeatUrl = (surveyId: number) => {
	return `/v1/survey-participation/surveys/${surveyId}/heartbeat`;
};

export const sendHeartbeat = async (
	surveyId: number,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getSendHeartbeatUrl(surveyId), {
		...options,
		method: "POST",
	});
};

export const getSendHeartbeatMutationOptions = <
	TError = Blob,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sendHeartbeat>>,
		TError,
		{ surveyId: number },
		TContext
	>;
	request?: SecondParameter<typeof apiClient>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sendHeartbeat>>,
	TError,
	{ surveyId: number },
	TContext
> => {
	const mutationKey = ["sendHeartbeat"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sendHeartbeat>>,
		{ surveyId: number }
	> = (props) => {
		const { surveyId } = props ?? {};

		return sendHeartbeat(surveyId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SendHeartbeatMutationResult = NonNullable<
	Awaited<ReturnType<typeof sendHeartbeat>>
>;

export type SendHeartbeatMutationError = Blob;

/**
 * @summary ÏÑ§Î¨∏ Ï∞∏Ïó¨ Ï§ëÏûÑÏùÑ ÏïåÎ¶ΩÎãàÎã§.
 */
export const useSendHeartbeat = <TError = Blob, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sendHeartbeat>>,
			TError,
			{ surveyId: number },
			TContext
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sendHeartbeat>>,
	TError,
	{ surveyId: number },
	TContext
> => {
	return useMutation(getSendHeartbeatMutationOptions(options), queryClient);
};
/**
 * @summary ÏÑ§Î¨∏ ÏûëÏÑ±ÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
 */
export const getCompleteSurveyUrl = (surveyId: number) => {
	return `/v1/survey-participation/surveys/${surveyId}/complete`;
};

export const completeSurvey = async (
	surveyId: number,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getCompleteSurveyUrl(surveyId), {
		...options,
		method: "POST",
	});
};

export const getCompleteSurveyMutationOptions = <
	TError = Blob,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof completeSurvey>>,
		TError,
		{ surveyId: number },
		TContext
	>;
	request?: SecondParameter<typeof apiClient>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof completeSurvey>>,
	TError,
	{ surveyId: number },
	TContext
> => {
	const mutationKey = ["completeSurvey"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof completeSurvey>>,
		{ surveyId: number }
	> = (props) => {
		const { surveyId } = props ?? {};

		return completeSurvey(surveyId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CompleteSurveyMutationResult = NonNullable<
	Awaited<ReturnType<typeof completeSurvey>>
>;

export type CompleteSurveyMutationError = Blob;

/**
 * @summary ÏÑ§Î¨∏ ÏûëÏÑ±ÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
 */
export const useCompleteSurvey = <TError = Blob, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof completeSurvey>>,
			TError,
			{ surveyId: number },
			TContext
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof completeSurvey>>,
	TError,
	{ surveyId: number },
	TContext
> => {
	return useMutation(getCompleteSurveyMutationOptions(options), queryClient);
};
/**
 * @summary Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠Ïóê ÎåÄÌïú ÏùëÎãµÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const getCreateScreeningAnswerUrl = (screeningId: number) => {
	return `/v1/survey-participation/screenings/${screeningId}`;
};

export const createScreeningAnswer = async (
	screeningId: number,
	insertScreeningAnswerRequest: InsertScreeningAnswerRequest,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getCreateScreeningAnswerUrl(screeningId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(insertScreeningAnswerRequest),
	});
};

export const getCreateScreeningAnswerMutationOptions = <
	TError = Blob,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createScreeningAnswer>>,
		TError,
		{ screeningId: number; data: InsertScreeningAnswerRequest },
		TContext
	>;
	request?: SecondParameter<typeof apiClient>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createScreeningAnswer>>,
	TError,
	{ screeningId: number; data: InsertScreeningAnswerRequest },
	TContext
> => {
	const mutationKey = ["createScreeningAnswer"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createScreeningAnswer>>,
		{ screeningId: number; data: InsertScreeningAnswerRequest }
	> = (props) => {
		const { screeningId, data } = props ?? {};

		return createScreeningAnswer(screeningId, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateScreeningAnswerMutationResult = NonNullable<
	Awaited<ReturnType<typeof createScreeningAnswer>>
>;
export type CreateScreeningAnswerMutationBody = InsertScreeningAnswerRequest;
export type CreateScreeningAnswerMutationError = Blob;

/**
 * @summary Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠Ïóê ÎåÄÌïú ÏùëÎãµÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const useCreateScreeningAnswer = <TError = Blob, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof createScreeningAnswer>>,
			TError,
			{ screeningId: number; data: InsertScreeningAnswerRequest },
			TContext
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof createScreeningAnswer>>,
	TError,
	{ screeningId: number; data: InsertScreeningAnswerRequest },
	TContext
> => {
	return useMutation(
		getCreateScreeningAnswerMutationOptions(options),
		queryClient,
	);
};
/**
 * @deprecated
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetTotalSurveyInfoOfSurveyIdUrl = (
	params: GetTotalSurveyInfoOfSurveyIdParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/survey-participation/surveys?${stringifiedParams}`
		: `/v1/survey-participation/surveys`;
};

export const getTotalSurveyInfoOfSurveyId = async (
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getGetTotalSurveyInfoOfSurveyIdUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetTotalSurveyInfoOfSurveyIdInfiniteQueryKey = (
	params?: GetTotalSurveyInfoOfSurveyIdParams,
) => {
	return [
		"infinite",
		`/v1/survey-participation/surveys`,
		...(params ? [params] : []),
	] as const;
};

export const getGetTotalSurveyInfoOfSurveyIdQueryKey = (
	params?: GetTotalSurveyInfoOfSurveyIdParams,
) => {
	return [
		`/v1/survey-participation/surveys`,
		...(params ? [params] : []),
	] as const;
};

export const getGetTotalSurveyInfoOfSurveyIdInfiniteQueryOptions = <
	TData = InfiniteData<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
	>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGetTotalSurveyInfoOfSurveyIdInfiniteQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
	> = ({ signal }) =>
		getTotalSurveyInfoOfSurveyId(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalSurveyInfoOfSurveyIdInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
>;
export type GetTotalSurveyInfoOfSurveyIdInfiniteQueryError = Blob;

export function useGetTotalSurveyInfoOfSurveyIdInfinite<
	TData = InfiniteData<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
	>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
					TError,
					Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalSurveyInfoOfSurveyIdInfinite<
	TData = InfiniteData<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
	>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
					TError,
					Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalSurveyInfoOfSurveyIdInfinite<
	TData = InfiniteData<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
	>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetTotalSurveyInfoOfSurveyIdInfinite<
	TData = InfiniteData<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
	>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetTotalSurveyInfoOfSurveyIdInfiniteQueryOptions(
		params,
		options,
	);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetTotalSurveyInfoOfSurveyIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetTotalSurveyInfoOfSurveyIdQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
	> = ({ signal }) =>
		getTotalSurveyInfoOfSurveyId(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalSurveyInfoOfSurveyIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
>;
export type GetTotalSurveyInfoOfSurveyIdQueryError = Blob;

export function useGetTotalSurveyInfoOfSurveyId<
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
					TError,
					Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalSurveyInfoOfSurveyId<
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
					TError,
					Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalSurveyInfoOfSurveyId<
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetTotalSurveyInfoOfSurveyId<
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetTotalSurveyInfoOfSurveyIdQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetTotalSurveyInfoOfSurveyIdSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetTotalSurveyInfoOfSurveyIdQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
	> = ({ signal }) =>
		getTotalSurveyInfoOfSurveyId(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalSurveyInfoOfSurveyIdSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>
>;
export type GetTotalSurveyInfoOfSurveyIdSuspenseQueryError = Blob;

export function useGetTotalSurveyInfoOfSurveyIdSuspense<
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalSurveyInfoOfSurveyIdSuspense<
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalSurveyInfoOfSurveyIdSuspense<
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetTotalSurveyInfoOfSurveyIdSuspense<
	TData = Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
	TError = Blob,
>(
	params: GetTotalSurveyInfoOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getTotalSurveyInfoOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetTotalSurveyInfoOfSurveyIdSuspenseQueryOptions(
		params,
		options,
	);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary ÏÑ∏Í∑∏Î©òÌÖåÏù¥ÏÖòÏóê ÏùºÏπòÌïòÎäî ÏÑ§Î¨∏Ïùò Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetRecommendedScreeningsUrl = (
	params?: GetRecommendedScreeningsParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/survey-participation/surveys/screenings?${stringifiedParams}`
		: `/v1/survey-participation/surveys/screenings`;
};

export const getRecommendedScreenings = async (
	params?: GetRecommendedScreeningsParams,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getGetRecommendedScreeningsUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetRecommendedScreeningsInfiniteQueryKey = (
	params?: GetRecommendedScreeningsParams,
) => {
	return [
		"infinite",
		`/v1/survey-participation/surveys/screenings`,
		...(params ? [params] : []),
	] as const;
};

export const getGetRecommendedScreeningsQueryKey = (
	params?: GetRecommendedScreeningsParams,
) => {
	return [
		`/v1/survey-participation/surveys/screenings`,
		...(params ? [params] : []),
	] as const;
};

export const getGetRecommendedScreeningsInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedScreenings>>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGetRecommendedScreeningsInfiniteQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getRecommendedScreenings>>
	> = ({ signal }) =>
		getRecommendedScreenings(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getRecommendedScreenings>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecommendedScreeningsInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getRecommendedScreenings>>
>;
export type GetRecommendedScreeningsInfiniteQueryError = Blob;

export function useGetRecommendedScreeningsInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedScreenings>>>,
	TError = Blob,
>(
	params: undefined | GetRecommendedScreeningsParams,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getRecommendedScreenings>>,
					TError,
					Awaited<ReturnType<typeof getRecommendedScreenings>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedScreeningsInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedScreenings>>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getRecommendedScreenings>>,
					TError,
					Awaited<ReturnType<typeof getRecommendedScreenings>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedScreeningsInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedScreenings>>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ∏Í∑∏Î©òÌÖåÏù¥ÏÖòÏóê ÏùºÏπòÌïòÎäî ÏÑ§Î¨∏Ïùò Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetRecommendedScreeningsInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedScreenings>>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetRecommendedScreeningsInfiniteQueryOptions(
		params,
		options,
	);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetRecommendedScreeningsQueryOptions = <
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetRecommendedScreeningsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getRecommendedScreenings>>
	> = ({ signal }) =>
		getRecommendedScreenings(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getRecommendedScreenings>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecommendedScreeningsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getRecommendedScreenings>>
>;
export type GetRecommendedScreeningsQueryError = Blob;

export function useGetRecommendedScreenings<
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params: undefined | GetRecommendedScreeningsParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getRecommendedScreenings>>,
					TError,
					Awaited<ReturnType<typeof getRecommendedScreenings>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedScreenings<
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getRecommendedScreenings>>,
					TError,
					Awaited<ReturnType<typeof getRecommendedScreenings>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedScreenings<
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ∏Í∑∏Î©òÌÖåÏù¥ÏÖòÏóê ÏùºÏπòÌïòÎäî ÏÑ§Î¨∏Ïùò Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetRecommendedScreenings<
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetRecommendedScreeningsQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetRecommendedScreeningsSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetRecommendedScreeningsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getRecommendedScreenings>>
	> = ({ signal }) =>
		getRecommendedScreenings(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getRecommendedScreenings>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecommendedScreeningsSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getRecommendedScreenings>>
>;
export type GetRecommendedScreeningsSuspenseQueryError = Blob;

export function useGetRecommendedScreeningsSuspense<
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params: undefined | GetRecommendedScreeningsParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedScreeningsSuspense<
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedScreeningsSuspense<
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ∏Í∑∏Î©òÌÖåÏù¥ÏÖòÏóê ÏùºÏπòÌïòÎäî ÏÑ§Î¨∏Ïùò Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetRecommendedScreeningsSuspense<
	TData = Awaited<ReturnType<typeof getRecommendedScreenings>>,
	TError = Blob,
>(
	params?: GetRecommendedScreeningsParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedScreenings>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetRecommendedScreeningsSuspenseQueryOptions(
		params,
		options,
	);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Îã®Ïùº Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetScreeningUrl = (screeningId: number) => {
	return `/v1/survey-participation/surveys/screenings/${screeningId}`;
};

export const getScreening = async (
	screeningId: number,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getGetScreeningUrl(screeningId), {
		...options,
		method: "GET",
	});
};

export const getGetScreeningInfiniteQueryKey = (screeningId: number) => {
	return [
		"infinite",
		`/v1/survey-participation/surveys/screenings/${screeningId}`,
	] as const;
};

export const getGetScreeningQueryKey = (screeningId: number) => {
	return [
		`/v1/survey-participation/surveys/screenings/${screeningId}`,
	] as const;
};

export const getGetScreeningInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getScreening>>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetScreeningInfiniteQueryKey(screeningId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getScreening>>> = ({
		signal,
	}) => getScreening(screeningId, { signal, ...requestOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!screeningId,
		...queryOptions,
	} as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getScreening>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetScreeningInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getScreening>>
>;
export type GetScreeningInfiniteQueryError = Blob;

export function useGetScreeningInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getScreening>>>,
	TError = Blob,
>(
	screeningId: number,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getScreening>>,
					TError,
					Awaited<ReturnType<typeof getScreening>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetScreeningInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getScreening>>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getScreening>>,
					TError,
					Awaited<ReturnType<typeof getScreening>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetScreeningInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getScreening>>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Îã®Ïùº Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetScreeningInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getScreening>>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetScreeningInfiniteQueryOptions(
		screeningId,
		options,
	);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetScreeningQueryOptions = <
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getScreening>>, TError, TData>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetScreeningQueryKey(screeningId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getScreening>>> = ({
		signal,
	}) => getScreening(screeningId, { signal, ...requestOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!screeningId,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof getScreening>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetScreeningQueryResult = NonNullable<
	Awaited<ReturnType<typeof getScreening>>
>;
export type GetScreeningQueryError = Blob;

export function useGetScreening<
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getScreening>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getScreening>>,
					TError,
					Awaited<ReturnType<typeof getScreening>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetScreening<
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getScreening>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getScreening>>,
					TError,
					Awaited<ReturnType<typeof getScreening>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetScreening<
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getScreening>>, TError, TData>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Îã®Ïùº Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetScreening<
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getScreening>>, TError, TData>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetScreeningQueryOptions(screeningId, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetScreeningSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetScreeningQueryKey(screeningId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getScreening>>> = ({
		signal,
	}) => getScreening(screeningId, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getScreening>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetScreeningSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getScreening>>
>;
export type GetScreeningSuspenseQueryError = Blob;

export function useGetScreeningSuspense<
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetScreeningSuspense<
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetScreeningSuspense<
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Îã®Ïùº Ïä§ÌÅ¨Î¶¨Îãù Î¨∏Ìï≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetScreeningSuspense<
	TData = Awaited<ReturnType<typeof getScreening>>,
	TError = Blob,
>(
	screeningId: number,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getScreening>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetScreeningSuspenseQueryOptions(
		screeningId,
		options,
	);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏Ïùò Î¨∏Ìï≠ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetQuestionsOfSurveyIdUrl = (
	params: GetQuestionsOfSurveyIdParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/survey-participation/surveys/questions?${stringifiedParams}`
		: `/v1/survey-participation/surveys/questions`;
};

export const getQuestionsOfSurveyId = async (
	params: GetQuestionsOfSurveyIdParams,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getGetQuestionsOfSurveyIdUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetQuestionsOfSurveyIdInfiniteQueryKey = (
	params?: GetQuestionsOfSurveyIdParams,
) => {
	return [
		"infinite",
		`/v1/survey-participation/surveys/questions`,
		...(params ? [params] : []),
	] as const;
};

export const getGetQuestionsOfSurveyIdQueryKey = (
	params?: GetQuestionsOfSurveyIdParams,
) => {
	return [
		`/v1/survey-participation/surveys/questions`,
		...(params ? [params] : []),
	] as const;
};

export const getGetQuestionsOfSurveyIdInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getQuestionsOfSurveyId>>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetQuestionsOfSurveyIdInfiniteQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
	> = ({ signal }) =>
		getQuestionsOfSurveyId(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsOfSurveyIdInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
>;
export type GetQuestionsOfSurveyIdInfiniteQueryError = Blob;

export function useGetQuestionsOfSurveyIdInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getQuestionsOfSurveyId>>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
					TError,
					Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsOfSurveyIdInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getQuestionsOfSurveyId>>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
					TError,
					Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsOfSurveyIdInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getQuestionsOfSurveyId>>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏Ïùò Î¨∏Ìï≠ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetQuestionsOfSurveyIdInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getQuestionsOfSurveyId>>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetQuestionsOfSurveyIdInfiniteQueryOptions(
		params,
		options,
	);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetQuestionsOfSurveyIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetQuestionsOfSurveyIdQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
	> = ({ signal }) =>
		getQuestionsOfSurveyId(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsOfSurveyIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
>;
export type GetQuestionsOfSurveyIdQueryError = Blob;

export function useGetQuestionsOfSurveyId<
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
					TError,
					Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsOfSurveyId<
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
					TError,
					Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsOfSurveyId<
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏Ïùò Î¨∏Ìï≠ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetQuestionsOfSurveyId<
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetQuestionsOfSurveyIdQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetQuestionsOfSurveyIdSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetQuestionsOfSurveyIdQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
	> = ({ signal }) =>
		getQuestionsOfSurveyId(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsOfSurveyIdSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getQuestionsOfSurveyId>>
>;
export type GetQuestionsOfSurveyIdSuspenseQueryError = Blob;

export function useGetQuestionsOfSurveyIdSuspense<
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsOfSurveyIdSuspense<
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsOfSurveyIdSuspense<
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏Ïùò Î¨∏Ìï≠ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetQuestionsOfSurveyIdSuspense<
	TData = Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
	TError = Blob,
>(
	params: GetQuestionsOfSurveyIdParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getQuestionsOfSurveyId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetQuestionsOfSurveyIdSuspenseQueryOptions(
		params,
		options,
	);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary ÎÖ∏Ï∂ú Ï§ëÏù∏ ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetSurveyListOnGoingUrl = (
	params?: GetSurveyListOnGoingParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/survey-participation/surveys/ongoing?${stringifiedParams}`
		: `/v1/survey-participation/surveys/ongoing`;
};

export const getSurveyListOnGoing = async (
	params?: GetSurveyListOnGoingParams,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getGetSurveyListOnGoingUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetSurveyListOnGoingInfiniteQueryKey = (
	params?: GetSurveyListOnGoingParams,
) => {
	return [
		"infinite",
		`/v1/survey-participation/surveys/ongoing`,
		...(params ? [params] : []),
	] as const;
};

export const getGetSurveyListOnGoingQueryKey = (
	params?: GetSurveyListOnGoingParams,
) => {
	return [
		`/v1/survey-participation/surveys/ongoing`,
		...(params ? [params] : []),
	] as const;
};

export const getGetSurveyListOnGoingInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyListOnGoing>>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSurveyListOnGoingInfiniteQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSurveyListOnGoing>>
	> = ({ signal }) =>
		getSurveyListOnGoing(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getSurveyListOnGoing>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSurveyListOnGoingInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSurveyListOnGoing>>
>;
export type GetSurveyListOnGoingInfiniteQueryError = Blob;

export function useGetSurveyListOnGoingInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyListOnGoing>>>,
	TError = Blob,
>(
	params: undefined | GetSurveyListOnGoingParams,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSurveyListOnGoing>>,
					TError,
					Awaited<ReturnType<typeof getSurveyListOnGoing>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyListOnGoingInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyListOnGoing>>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSurveyListOnGoing>>,
					TError,
					Awaited<ReturnType<typeof getSurveyListOnGoing>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyListOnGoingInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyListOnGoing>>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÖ∏Ï∂ú Ï§ëÏù∏ ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetSurveyListOnGoingInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyListOnGoing>>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetSurveyListOnGoingInfiniteQueryOptions(
		params,
		options,
	);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetSurveyListOnGoingQueryOptions = <
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSurveyListOnGoingQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSurveyListOnGoing>>
	> = ({ signal }) =>
		getSurveyListOnGoing(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSurveyListOnGoing>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSurveyListOnGoingQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSurveyListOnGoing>>
>;
export type GetSurveyListOnGoingQueryError = Blob;

export function useGetSurveyListOnGoing<
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params: undefined | GetSurveyListOnGoingParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSurveyListOnGoing>>,
					TError,
					Awaited<ReturnType<typeof getSurveyListOnGoing>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyListOnGoing<
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSurveyListOnGoing>>,
					TError,
					Awaited<ReturnType<typeof getSurveyListOnGoing>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyListOnGoing<
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÖ∏Ï∂ú Ï§ëÏù∏ ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetSurveyListOnGoing<
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetSurveyListOnGoingQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetSurveyListOnGoingSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSurveyListOnGoingQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSurveyListOnGoing>>
	> = ({ signal }) =>
		getSurveyListOnGoing(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getSurveyListOnGoing>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSurveyListOnGoingSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSurveyListOnGoing>>
>;
export type GetSurveyListOnGoingSuspenseQueryError = Blob;

export function useGetSurveyListOnGoingSuspense<
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params: undefined | GetSurveyListOnGoingParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyListOnGoingSuspense<
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyListOnGoingSuspense<
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎÖ∏Ï∂ú Ï§ëÏù∏ ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetSurveyListOnGoingSuspense<
	TData = Awaited<ReturnType<typeof getSurveyListOnGoing>>,
	TError = Blob,
>(
	params?: GetSurveyListOnGoingParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyListOnGoing>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetSurveyListOnGoingSuspenseQueryOptions(
		params,
		options,
	);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary ÏÇ¨Ïö©Ïûê Ï∂îÏ≤ú ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetRecommendedSurveyListUrl = (
	params?: GetRecommendedSurveyListParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/survey-participation/surveys/ongoing/recommended?${stringifiedParams}`
		: `/v1/survey-participation/surveys/ongoing/recommended`;
};

export const getRecommendedSurveyList = async (
	params?: GetRecommendedSurveyListParams,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getGetRecommendedSurveyListUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetRecommendedSurveyListInfiniteQueryKey = (
	params?: GetRecommendedSurveyListParams,
) => {
	return [
		"infinite",
		`/v1/survey-participation/surveys/ongoing/recommended`,
		...(params ? [params] : []),
	] as const;
};

export const getGetRecommendedSurveyListQueryKey = (
	params?: GetRecommendedSurveyListParams,
) => {
	return [
		`/v1/survey-participation/surveys/ongoing/recommended`,
		...(params ? [params] : []),
	] as const;
};

export const getGetRecommendedSurveyListInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedSurveyList>>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGetRecommendedSurveyListInfiniteQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getRecommendedSurveyList>>
	> = ({ signal }) =>
		getRecommendedSurveyList(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getRecommendedSurveyList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecommendedSurveyListInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getRecommendedSurveyList>>
>;
export type GetRecommendedSurveyListInfiniteQueryError = Blob;

export function useGetRecommendedSurveyListInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedSurveyList>>>,
	TError = Blob,
>(
	params: undefined | GetRecommendedSurveyListParams,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getRecommendedSurveyList>>,
					TError,
					Awaited<ReturnType<typeof getRecommendedSurveyList>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedSurveyListInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedSurveyList>>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getRecommendedSurveyList>>,
					TError,
					Awaited<ReturnType<typeof getRecommendedSurveyList>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedSurveyListInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedSurveyList>>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÇ¨Ïö©Ïûê Ï∂îÏ≤ú ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetRecommendedSurveyListInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedSurveyList>>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetRecommendedSurveyListInfiniteQueryOptions(
		params,
		options,
	);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetRecommendedSurveyListQueryOptions = <
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetRecommendedSurveyListQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getRecommendedSurveyList>>
	> = ({ signal }) =>
		getRecommendedSurveyList(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getRecommendedSurveyList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecommendedSurveyListQueryResult = NonNullable<
	Awaited<ReturnType<typeof getRecommendedSurveyList>>
>;
export type GetRecommendedSurveyListQueryError = Blob;

export function useGetRecommendedSurveyList<
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params: undefined | GetRecommendedSurveyListParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getRecommendedSurveyList>>,
					TError,
					Awaited<ReturnType<typeof getRecommendedSurveyList>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedSurveyList<
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getRecommendedSurveyList>>,
					TError,
					Awaited<ReturnType<typeof getRecommendedSurveyList>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedSurveyList<
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÇ¨Ïö©Ïûê Ï∂îÏ≤ú ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetRecommendedSurveyList<
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetRecommendedSurveyListQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetRecommendedSurveyListSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetRecommendedSurveyListQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getRecommendedSurveyList>>
	> = ({ signal }) =>
		getRecommendedSurveyList(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getRecommendedSurveyList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecommendedSurveyListSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getRecommendedSurveyList>>
>;
export type GetRecommendedSurveyListSuspenseQueryError = Blob;

export function useGetRecommendedSurveyListSuspense<
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params: undefined | GetRecommendedSurveyListParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedSurveyListSuspense<
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecommendedSurveyListSuspense<
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÇ¨Ïö©Ïûê Ï∂îÏ≤ú ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetRecommendedSurveyListSuspense<
	TData = Awaited<ReturnType<typeof getRecommendedSurveyList>>,
	TError = Blob,
>(
	params?: GetRecommendedSurveyListParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getRecommendedSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetRecommendedSurveyListSuspenseQueryOptions(
		params,
		options,
	);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary ÎßàÍ∞ê ÏûÑÎ∞ï ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetImpendingSurveyListUrl = (
	params?: GetImpendingSurveyListParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/survey-participation/surveys/ongoing/impending?${stringifiedParams}`
		: `/v1/survey-participation/surveys/ongoing/impending`;
};

export const getImpendingSurveyList = async (
	params?: GetImpendingSurveyListParams,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getGetImpendingSurveyListUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetImpendingSurveyListInfiniteQueryKey = (
	params?: GetImpendingSurveyListParams,
) => {
	return [
		"infinite",
		`/v1/survey-participation/surveys/ongoing/impending`,
		...(params ? [params] : []),
	] as const;
};

export const getGetImpendingSurveyListQueryKey = (
	params?: GetImpendingSurveyListParams,
) => {
	return [
		`/v1/survey-participation/surveys/ongoing/impending`,
		...(params ? [params] : []),
	] as const;
};

export const getGetImpendingSurveyListInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getImpendingSurveyList>>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetImpendingSurveyListInfiniteQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getImpendingSurveyList>>
	> = ({ signal }) =>
		getImpendingSurveyList(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getImpendingSurveyList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetImpendingSurveyListInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getImpendingSurveyList>>
>;
export type GetImpendingSurveyListInfiniteQueryError = Blob;

export function useGetImpendingSurveyListInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getImpendingSurveyList>>>,
	TError = Blob,
>(
	params: undefined | GetImpendingSurveyListParams,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getImpendingSurveyList>>,
					TError,
					Awaited<ReturnType<typeof getImpendingSurveyList>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetImpendingSurveyListInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getImpendingSurveyList>>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getImpendingSurveyList>>,
					TError,
					Awaited<ReturnType<typeof getImpendingSurveyList>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetImpendingSurveyListInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getImpendingSurveyList>>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎßàÍ∞ê ÏûÑÎ∞ï ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetImpendingSurveyListInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getImpendingSurveyList>>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetImpendingSurveyListInfiniteQueryOptions(
		params,
		options,
	);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetImpendingSurveyListQueryOptions = <
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetImpendingSurveyListQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getImpendingSurveyList>>
	> = ({ signal }) =>
		getImpendingSurveyList(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getImpendingSurveyList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetImpendingSurveyListQueryResult = NonNullable<
	Awaited<ReturnType<typeof getImpendingSurveyList>>
>;
export type GetImpendingSurveyListQueryError = Blob;

export function useGetImpendingSurveyList<
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params: undefined | GetImpendingSurveyListParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getImpendingSurveyList>>,
					TError,
					Awaited<ReturnType<typeof getImpendingSurveyList>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetImpendingSurveyList<
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getImpendingSurveyList>>,
					TError,
					Awaited<ReturnType<typeof getImpendingSurveyList>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetImpendingSurveyList<
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎßàÍ∞ê ÏûÑÎ∞ï ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetImpendingSurveyList<
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetImpendingSurveyListQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetImpendingSurveyListSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetImpendingSurveyListQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getImpendingSurveyList>>
	> = ({ signal }) =>
		getImpendingSurveyList(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getImpendingSurveyList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetImpendingSurveyListSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getImpendingSurveyList>>
>;
export type GetImpendingSurveyListSuspenseQueryError = Blob;

export function useGetImpendingSurveyListSuspense<
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params: undefined | GetImpendingSurveyListParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetImpendingSurveyListSuspense<
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetImpendingSurveyListSuspense<
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÎßàÍ∞ê ÏûÑÎ∞ï ÏÑ§Î¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetImpendingSurveyListSuspense<
	TData = Awaited<ReturnType<typeof getImpendingSurveyList>>,
	TError = Blob,
>(
	params?: GetImpendingSurveyListParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getImpendingSurveyList>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetImpendingSurveyListSuspenseQueryOptions(
		params,
		options,
	);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏Ïùò Í∏∞Î≥∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetSurveyInfoUrl = (params: GetSurveyInfoParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/survey-participation/surveys/info?${stringifiedParams}`
		: `/v1/survey-participation/surveys/info`;
};

export const getSurveyInfo = async (
	params: GetSurveyInfoParams,
	options?: RequestInit,
): Promise<Blob> => {
	return apiClient<Blob>(getGetSurveyInfoUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetSurveyInfoInfiniteQueryKey = (
	params?: GetSurveyInfoParams,
) => {
	return [
		"infinite",
		`/v1/survey-participation/surveys/info`,
		...(params ? [params] : []),
	] as const;
};

export const getGetSurveyInfoQueryKey = (params?: GetSurveyInfoParams) => {
	return [
		`/v1/survey-participation/surveys/info`,
		...(params ? [params] : []),
	] as const;
};

export const getGetSurveyInfoInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyInfo>>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSurveyInfoInfiniteQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSurveyInfo>>> = ({
		signal,
	}) => getSurveyInfo(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getSurveyInfo>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSurveyInfoInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSurveyInfo>>
>;
export type GetSurveyInfoInfiniteQueryError = Blob;

export function useGetSurveyInfoInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyInfo>>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSurveyInfo>>,
					TError,
					Awaited<ReturnType<typeof getSurveyInfo>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyInfoInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyInfo>>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSurveyInfo>>,
					TError,
					Awaited<ReturnType<typeof getSurveyInfo>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyInfoInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyInfo>>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏Ïùò Í∏∞Î≥∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetSurveyInfoInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getSurveyInfo>>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetSurveyInfoInfiniteQueryOptions(params, options);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetSurveyInfoQueryOptions = <
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSurveyInfo>>, TError, TData>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSurveyInfoQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSurveyInfo>>> = ({
		signal,
	}) => getSurveyInfo(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSurveyInfo>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSurveyInfoQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSurveyInfo>>
>;
export type GetSurveyInfoQueryError = Blob;

export function useGetSurveyInfo<
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSurveyInfo>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSurveyInfo>>,
					TError,
					Awaited<ReturnType<typeof getSurveyInfo>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyInfo<
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSurveyInfo>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSurveyInfo>>,
					TError,
					Awaited<ReturnType<typeof getSurveyInfo>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyInfo<
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSurveyInfo>>, TError, TData>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏Ïùò Í∏∞Î≥∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetSurveyInfo<
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSurveyInfo>>, TError, TData>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetSurveyInfoQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

export const getGetSurveyInfoSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSurveyInfoQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSurveyInfo>>> = ({
		signal,
	}) => getSurveyInfo(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getSurveyInfo>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSurveyInfoSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSurveyInfo>>
>;
export type GetSurveyInfoSuspenseQueryError = Blob;

export function useGetSurveyInfoSuspense<
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyInfoSuspense<
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSurveyInfoSuspense<
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÏÑ†ÌÉùÌïú ÏÑ§Î¨∏Ïùò Í∏∞Î≥∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetSurveyInfoSuspense<
	TData = Awaited<ReturnType<typeof getSurveyInfo>>,
	TError = Blob,
>(
	params: GetSurveyInfoParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getSurveyInfo>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof apiClient>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetSurveyInfoSuspenseQueryOptions(params, options);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return { ...query, queryKey: queryOptions.queryKey };
}
